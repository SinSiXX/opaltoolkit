\documentclass[conference]{IEEEtran}

\usepackage{graphicx}

\begin{document}

% paper title
\title{On Supporting Molecular Visualization on Grid Resources using Visual
  Programming Environments}

% author information
\author{\authorblockN{Sriram Krishnan\authorrefmark{1}\authorrefmark{2},
    Guillaume Vareille\authorrefmark{3},
    Wesley Goodman\authorrefmark{1},
    Luca Clementi\authorrefmark{1},\\
    Jane Ren\authorrefmark{1},
    Sargis Dallakyan\authorrefmark{3},
    Wilfred Li\authorrefmark{1}\authorrefmark{2},
    Michel Sanner\authorrefmark{3} and
    Peter Arzberger\authorrefmark{1}}
  \authorblockA{\authorrefmark{1}National Biomedical Computation Resource\\
    CRBS, UC San Diego, 9500 Gilman Dr, La Jolla, CA 92093}
  \authorblockA{\authorrefmark{2}San Diego Supercomputer Center\\
    UC San Diego MC 0505, 9500 Gilman Dr, La Jolla, CA 92093}
  \authorblockA{\authorrefmark{3}The Molecular Graphics Lab\\
    The Scripps Research Institute, La Jolla, CA 92093
    }
  \authorblockA{sriram@sdsc.edu, vareille@scripps.edu, \{wgoodman,
      lclement, j2ren@ucsd.edu\},\\
      wilfred@sdsc.edu, sanner@scripps.edu, parzberger@ucsd.edu}
  }


% make the title area
\maketitle

\begin{abstract}

  The visual programming paradigm provided by tools such as AVS [ref],
  OpenDX [ref], SciRun [ref], etc have been around for a couple decades.
  Recently, with the advent of the Web 2.0 paradigm and the concept of {\em
    mashups} [ref], there has been renewed interest in such types of
  environments. Over the past several years, we have developed one such
  tool called Vision [ref], which is a component-based, application-domain
  agnostic, cross-platform visual programming environment. Meanwhile,
  advances in distributed and Grid computing have opened up avenues for
  scientists to run large simulations on a scale that was impossible until
  recent times. In the past, visual programming tools were generally
  limited to running scientific experiments on user's individual
  workstations, and had limited capability to use distributed resources.
  With the proliferation of Web services, distributed resources are much
  more easy to access from any workstation that is connected to the
  Internet. In particular, we have developed the Opal toolkit, which
  provides a mechanism to wrap scientific applications running on Grid
  resources as Web services, thus providing the clients with a simple Web
  API to the back-end computational functionality. Opal encapsulates
  standard Grid security mechanisms, schedulers, and state management for
  jobs, and also provides a mechanism to describe command-line arguments
  that can be used to automatically generate user-interfaces [ref]. In this
  paper, we describe our current work on enabling access to scientific
  applications running on Grid resources via Opal from the Vision
  environment. We present brief overviews of both Vision and Opal, and
  discuss a scientific workflow that has been implemented with the above
  tools. We discuss our experiences, and plans for future work.

\end{abstract}

\section{Intro on scientific workflows and grid computing}

- Scientific workflows: Michel

The visual-programming paradigm provided by tools such as the AVS [X],
OpenDX [X], Khoros [X], DataExplorer [X], Ptoleme [X] or Scirun, [X] has
been around for a couple of decades. Recently, there has recently been a
renewed interest in this type of user interface and numerous pipelining
tools have become available, including: PHENIX [x], pipeline pilot [X],
mapero [X], Orange [X], Elefant [X], Kepler [X], Taverna [X] to name a few.

These software environments, allow a user to construct a computational
network by placing nodes performing a specific task onto a canvas and
connecting their output and input ports using pipes that specify the flow
of data through the network. The appeal of this type of interface is that
the user can interactively construct networks of computational nodes that
correspond to simple programs without having to write a single line of
code. It provides an effective way to hide syntax details and data
structures used to store data from the user who in general cares more about
the result of the computation rather than these implementation details. In
other words it empowers users with an unprecedented level of flexibility in
using computers without having to become a programmer.

While some of these tools are highly specific to a given application
domain, other try to be more generic programming environments. However,
most of these programs are what we call “application-centric” (i.e. they
constitute the development environment for a specific application) rather
than being a software component that will integrate and dovetail nicely
with other software components and that does not make assumptions about the
domain of application.

- Grid computing: Sriram

\section {Background}

\subsection {The Vision Environment}

% - Design -- workflow representation and control: Michel

% - API -- how to write Vision nodes, introspection, etc: Michel

Over the past 8 years we have developed Vision [X], a component-based,
application-domain agnostic, cross-platform visual programming environment.
Vision has been designed as an extension to the Python programming language
[X] thus providing a fully fledged, high level, object-oriented,
interpretive language for the interactive manipulation of data and/or
modification of the application itself.

The Vision framework was designed to dynamically load libraries of
computational nodes providing specific functionality. Not only does this
approach reduce the footprint of Vision in memory, but it also avoids
cluttering the interface with nodes that a particular user might not be
interested in using. Each library can define its own data types, allowing
the validation of data passed to a node before the node will execute. A
data type definition includes a description of the visual representation of
ports receiving or sending this data type, thus providing visual clues to
the user while he create the data flow by connecting output ports to input
ports. Port can be declared as required or optional. A node can only run if
all required ports present valid data. Introspection tools allow the user
to inspect data on input ports and output ports in real time.

Vision network nodes are Python objects that provide input ports and output
ports. When a node is scheduled for execution, it will collect the data on
its input ports and pass it ot the node’s compute function. This function
typically imports Python code from some other Python package to operate on
the data and produce a result, which is then sent to the node’s output
port. This important design features makes Vision “just another” user
interface to functionality available to any program running a Python
interpreter thus promoting code re-use and inter-operability. Moreover,
since the node’s compute function is written in the Python programming
language it can be inspected and modified interactively by the user.  In
fact, a node can be designed interactively in Vision using the node editor.
All modifications made to a node or a network, are saved in the network
description file. This file contains Python code that will recreate the
network when executed. We made this choice in order to avoid having to
define a format for describing networks and also to have access to the full
power of a programming language for the definition of these networks.

Vision supports the concept of MacroNodes which appear as a simple node in
a network, but encapsulate a sub-network. MacroNodes can exist inside
Macronodes, thus allowing a hierarchical visual representation of algorithm
and facilitating code reuse within Vision.

While execution of a node is typically triggered by new data presented on
its ports, a node can also be triggered by events such as the completion of
another node’s execution. Vision’s execution model allows for the partial
execution of networks. When a parameter changes or new data is provided for
a given node, only the sub-graph of children nodes depending on this
parameter or dataset will re-compute.

An iterate node supports the implementation of “for loops” in Vision. This
node loops over any sequence of Python objects and triggers the sub-network
of its children nodes for each one of the objects in the sequence. Begin
and end of loop events allow the accumulation of data during a loop and the
execution of code after the completion of the loop. 

To date, several libraries of nodes are available [Fig X]. The standard
library comprises nodes exposing Python keywords (print, eval, setattr and
call methods), along with nodes enabling the generation of simple input
data such as floats, integers, and strings. The 3-D Visualization library
is based on the DejaVu component and provides nodes to create 3-D
geometries and display them. The SymServ library implements a set of nodes
defining geometric transformations such as symmetries, translation,
rotation, helical arrangements etc. that can be combined to created streams
of nested 3-D transformations. The MolKit library is based on the MolKit
package and provides nodes to read molecular data files and manipulate
molecules. The Imaging library currently exposes a subset of the
functionality available in the Python Image Library (PIL) thus enabling the
creation of image processing pipelines.

So far, Vision has essentially been used in an interactive way with most
computational nodes running locally (i.e. in the same process as the Python
interpreter running Vision). In this paper we describe the addition of
support for nodes running web services. 

% - Comparison with other tools: Luca

%   - Kepler, Ptolemy and MoML

%   - Taverna, Scufl and Freeflou

\subsection {Related Work}

Several tools have been developed by the scientific community to support
the design and execution of workflows. Each one of them use different
approaches to model a graphical environment for designing and executing
workflow.  In this section we present three workflow management systems:
Kepler, Taverna, and AVS. This paragraph does not want to provide an
exaustive survey of these systems, for more information refer to [grid].

Kepler [6] is a workflow system developed under several research projects.
It is written in Java and based on Ptolemy II [6], a system originally
created to study modeling, simulation, and design of concurrent systems.
Kepler models workflow in MoMl, a markup language developed in Ptolemy that
is based on the concept of actors. Each actor has input and output ports
and wraps typical workflow actions like invoke a Web Service or a Grid
Services, launch a Globus Grid Jobs, perform a GridFTP transfer, and many
others. The designer can model non Directed Acyclic Graph [5] using a
simple Graphic User Interface where the user has simply to drag and drop
icons and connect them.  Kepler can also be classified as a workflow system
based on the data flow model [6], where data is streamed from one actor to
another triggering their activation. Moreover an extensible architecture
based on the plugin model allows developers to easily interagte thrid party
tools.

Taverna is an open source software tool for designing and executing
bioinformatics workflows, developed in the myGrid project [7]. It uses
Scufl as a runtime language for the execution of the workflow, and Freefluo
as an execution engine. Scufl can be extended using Processor plugins that
manage the interaction with different external service interfaces. Taverna
is shipped with a set of processors that guarantee interaction with
services based on WS-I standard. The designer is based on a directed ciclic
graph that represents data flow, which uses a simple graphical notation
developed by the Taverna team. The GUI can be easily extended creating new
palettes and new widgets with development of new plugins.

\section {Application based services}

- Opal wrapper and GUI \cite{opal}: Sriram 

- Opal and Opal-CSF4: Sriram

- Data services: Sriram

\section {Service based workflows}

- Vision based grid workflows (Michel, Guillaume, Sargis)

- Virtualization of Opal services (Sargis - something about how you
automatically create Vision nodes from the service list)

- Virtualization of Vision based workflows

  i) Use a local CLI opal client to access local or remote services (Sriram)

 ii) Automatic vision node creation through the opal client information
 service (Sriram, Guillaume - how the generated class is converted into a Vision node using introspection)

\section {Discussion - Workflow modeling and execution}

- How vision currently stores workflow (Michel)

- Fault tolerance (Michel, Sriram)

- Support for XPDL and other representations for workflows (Luca)

\section {Conclusions}

- Conclusions (Sriram)

%% References
\bibliographystyle{plain}
\bibliography{paper}

% that's all folks
\end{document}
