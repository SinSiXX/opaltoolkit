\documentclass[conference]{IEEEtran}

\usepackage{graphicx}

\begin{document}

% paper title
\title{On Supporting Molecular Visualization on Grid Resources using Visual
  Programming Environments}

% author information
\author{\authorblockN{Sriram Krishnan\authorrefmark{1}\authorrefmark{2},
    Guillaume Vareille\authorrefmark{3},
    Wesley Goodman\authorrefmark{1},
    Luca Clementi\authorrefmark{1},\\
    Jane Ren\authorrefmark{1},
    Sargis Dallakyan\authorrefmark{3},
    Wilfred Li\authorrefmark{1}\authorrefmark{2},
    Michel Sanner\authorrefmark{3} and
    Peter Arzberger\authorrefmark{1}}
  \authorblockA{\authorrefmark{1}National Biomedical Computation Resource\\
    CRBS, UC San Diego, 9500 Gilman Dr, La Jolla, CA 92093}
  \authorblockA{\authorrefmark{2}San Diego Supercomputer Center\\
    UC San Diego MC 0505, 9500 Gilman Dr, La Jolla, CA 92093}
  \authorblockA{\authorrefmark{3}The Molecular Graphics Lab\\
    The Scripps Research Institute, La Jolla, CA 92093
    }
  \authorblockA{sriram@sdsc.edu, vareille@scripps.edu, \{wgoodman,
      lclement, j2ren@ucsd.edu\},\\
      wilfred@sdsc.edu, sanner@scripps.edu, parzberger@ucsd.edu}
  }


% make the title area
\maketitle

\begin{abstract}

  The visual programming paradigm provided by tools such as AVS [ref],
  OpenDX [ref], SciRun [ref], etc have been around for a couple decades.
  Recently, with the advent of the Web 2.0 paradigm and the concept of {\em
    mashups} [ref], there has been renewed interest in such types of
  environments. Over the past several years, we have developed one such
  tool called Vision [ref], which is a component-based, application-domain
  agnostic, cross-platform visual programming environment. Meanwhile,
  advances in distributed and Grid computing have opened up avenues for
  scientists to run large simulations on a scale that was impossible until
  recent times. In the past, visual programming tools were generally
  limited to running scientific experiments on user's individual
  workstations, and had limited capability to use distributed resources.
  With the proliferation of Web services, distributed resources are much
  more easy to access from any workstation that is connected to the
  Internet. In particular, we have developed the Opal toolkit, which
  provides a mechanism to wrap scientific applications running on Grid
  resources as Web services, thus providing the clients with a simple Web
  API to the back-end computational functionality. Opal encapsulates
  standard Grid security mechanisms, schedulers, and state management for
  jobs, and also provides a mechanism to describe command-line arguments
  that can be used to automatically generate user-interfaces [ref]. In this
  paper, we describe our current work on enabling access to scientific
  applications running on Grid resources via Opal from the Vision
  environment. We present brief overviews of both Vision and Opal, and
  discuss a scientific workflow that has been implemented with the above
  tools. We discuss our experiences, and plans for future work.

\end{abstract}

\section{Intro on scientific workflows and grid computing}

- Scientific workflows: Michel

The visual-programming paradigm provided by tools such as the AVS [X],
OpenDX [X], Khoros [X], DataExplorer [X], Ptoleme [X] or Scirun, [X] has
been around for a couple of decades. Recently, there has recently been a
renewed interest in this type of user interface and numerous pipelining
tools have become available, including: PHENIX [x], pipeline pilot [X],
mapero [X], Orange [X], Elefant [X], Kepler [X], Taverna [X] to name a few.

These software environments, allow a user to construct a computational
network by placing nodes performing a specific task onto a canvas and
connecting their output and input ports using pipes that specify the flow
of data through the network. The appeal of this type of interface is that
the user can interactively construct networks of computational nodes that
correspond to simple programs without having to write a single line of
code. It provides an effective way to hide syntax details and data
structures used to store data from the user who in general cares more about
the result of the computation rather than these implementation details. In
other words it empowers users with an unprecedented level of flexibility in
using computers without having to become a programmer.

While some of these tools are highly specific to a given application
domain, other try to be more generic programming environments. However,
most of these programs are what we call “application-centric” (i.e. they
constitute the development environment for a specific application) rather
than being a software component that will integrate and dovetail nicely
with other software components and that does not make assumptions about the
domain of application.

- Grid computing: Sriram

\section {Visual Programming Environments}

\subsection {The Vision Environment}

% - Design -- workflow representation and control: Michel

% - API -- how to write Vision nodes, introspection, etc: Michel

Over the past 8 years we have developed Vision [X], a component-based,
application-domain agnostic, cross-platform visual programming environment.
Vision has been designed as an extension to the Python programming language
[X] thus providing a fully fledged, high level, object-oriented,
interpretive language for the interactive manipulation of data and/or
modification of the application itself.

The Vision framework was designed to dynamically load libraries of
computational nodes providing specific functionality. Not only does this
approach reduce the footprint of Vision in memory, but it also avoids
cluttering the interface with nodes that a particular user might not be
interested in using. Each library can define its own data types, allowing
the validation of data passed to a node before the node will execute. A
data type definition includes a description of the visual representation of
ports receiving or sending this data type, thus providing visual clues to
the user while he create the data flow by connecting output ports to input
ports. Port can be declared as required or optional. A node can only run if
all required ports present valid data. Introspection tools allow the user
to inspect data on input ports and output ports in real time.

Vision network nodes are Python objects that provide input ports and output
ports. When a node is scheduled for execution, it will collect the data on
its input ports and pass it ot the node’s compute function. This function
typically imports Python code from some other Python package to operate on
the data and produce a result, which is then sent to the node’s output
port. This important design features makes Vision “just another” user
interface to functionality available to any program running a Python
interpreter thus promoting code re-use and inter-operability. Moreover,
since the node’s compute function is written in the Python programming
language it can be inspected and modified interactively by the user.  In
fact, a node can be designed interactively in Vision using the node editor.
All modifications made to a node or a network, are saved in the network
description file. This file contains Python code that will recreate the
network when executed. We made this choice in order to avoid having to
define a format for describing networks and also to have access to the full
power of a programming language for the definition of these networks.

Vision supports the concept of MacroNodes which appear as a simple node in
a network, but encapsulate a sub-network. MacroNodes can exist inside
Macronodes, thus allowing a hierarchical visual representation of algorithm
and facilitating code reuse within Vision.

While execution of a node is typically triggered by new data presented on
its ports, a node can also be triggered by events such as the completion of
another node’s execution. Vision’s execution model allows for the partial
execution of networks. When a parameter changes or new data is provided for
a given node, only the sub-graph of children nodes depending on this
parameter or dataset will re-compute.

An iterate node supports the implementation of “for loops” in Vision. This
node loops over any sequence of Python objects and triggers the sub-network
of its children nodes for each one of the objects in the sequence. Begin
and end of loop events allow the accumulation of data during a loop and the
execution of code after the completion of the loop. 

To date, several libraries of nodes are available [Fig X]. The standard
library comprises nodes exposing Python keywords (print, eval, setattr and
call methods), along with nodes enabling the generation of simple input
data such as floats, integers, and strings. The 3-D Visualization library
is based on the DejaVu component and provides nodes to create 3-D
geometries and display them. The SymServ library implements a set of nodes
defining geometric transformations such as symmetries, translation,
rotation, helical arrangements etc. that can be combined to created streams
of nested 3-D transformations. The MolKit library is based on the MolKit
package and provides nodes to read molecular data files and manipulate
molecules. The Imaging library currently exposes a subset of the
functionality available in the Python Image Library (PIL) thus enabling the
creation of image processing pipelines.

So far, Vision has essentially been used in an interactive way with most
computational nodes running locally (i.e. in the same process as the Python
interpreter running Vision). In this paper we describe the addition of
support for nodes running web services. 

% - Comparison with other tools: Luca

%   - Kepler, Ptolemy and MoML

%   - Taverna, Scufl and Freeflou

\subsection {Related Work}

Several tools have been developed by the scientific community to support
the design and execution of workflows. Each one of them use different
approaches to model a graphical environment for designing and executing
workflow.  In this section we present three workflow management systems:
Kepler, Taverna, and AVS. This paragraph does not want to provide an
exaustive survey of these systems, for more information refer to [grid].

Kepler [6] is a workflow system developed under several research projects.
It is written in Java and based on Ptolemy II [6], a system originally
created to study modeling, simulation, and design of concurrent systems.
Kepler models workflow in MoMl, a markup language developed in Ptolemy that
is based on the concept of actors. Each actor has input and output ports
and wraps typical workflow actions like invoke a Web Service or a Grid
Services, launch a Globus Grid Jobs, perform a GridFTP transfer, and many
others. The designer can model non Directed Acyclic Graph [5] using a
simple Graphic User Interface where the user has simply to drag and drop
icons and connect them.  Kepler can also be classified as a workflow system
based on the data flow model [6], where data is streamed from one actor to
another triggering their activation. Moreover an extensible architecture
based on the plugin model allows developers to easily interagte thrid party
tools.

Taverna is an open source software tool for designing and executing
bioinformatics workflows, developed in the myGrid project [7]. It uses
Scufl as a runtime language for the execution of the workflow, and Freefluo
as an execution engine. Scufl can be extended using Processor plugins that
manage the interaction with different external service interfaces. Taverna
is shipped with a set of processors that guarantee interaction with
services based on WS-I standard. The designer is based on a directed ciclic
graph that represents data flow, which uses a simple graphical notation
developed by the Taverna team. The GUI can be easily extended creating new
palettes and new widgets with development of new plugins.

\section {Services Oriented Science}

Programming and using distributed Grid resources is quite a challenge task.
There is hope that Service-Oriented Architectures (SOA) can address this
problem by providing platform-independent, language-neutral service
interfaces that hide the complexity of the implementations while providing
a well-defined and high-performance Quality of Service (QoS). In our recent
paper [ref], we claimed that in order to lower the entrance barrier for
scientific application developers and end-users to Grid infrastructures, we
must do the following: 

% TODO: possibly expand every bullet
\begin{itemize}
\item{Focus on application-level services}
\item{Provide users access to virtualized resources}
\item{Provide multiple user interfaces to scientific users}
\item{Lower deployment costs}
\item{Follow the Web 2.0 paradigm by enabling user participation and contribution}
\end{itemize}

Towards this end, we have developed the Opal toolkit
\cite{opal} for wrapping scientific applications as Web services. In order
to wrap an application as a Web service, application developers are
expected to write a simple XML-based application configuration. The
application configuration contains information about the scientific
application, such as application name, binary location, and application
metadata (e.g. usage information). Using a simple Apache Ant task, the Opal
toolkit can deploy the application as a Web service into a container based
on Apache Tomcat and Axis. Once the application is deployed as a Web
service, clients can access this service programmatically using its WSDL
description. The WSDL API provides operations for job launch (which accepts
command-line arguments and input files as its parameters), querying status,
and retrieving outputs. Furthermore, it also provides an API for retrieving
application metadata. WSDL savvy users could write their own clients to
access Opal based applications. However, not every scientific user is
capable or interested in writing Web service clients. Hence, several
interfaces have been provided for the end-user. Apart from command-line
clients written in languages like Java, Python [4] and Perl [15] available
from NBCR, Web interfaces for Opal based services are available through the
GridSphere portal environment [18], such as the MEME portlet in My
WorkSphere [24]. In addition, Opal based interfaces via Rich Internet
Applications (RIA) such as Gemstone [20], and Problem Solving Environments
(PSE) such as the Python Molecular Viewer (PMV) [22], AutoDockTools [21]
and Continuity [27] have also been provided.

\begin{figure}
\begin{center}
\includegraphics[width=8cm]{architecture}
\end{center}
\caption{Services Oriented Science Using the Opal Toolkit}
\label{fig:arch}
\end{figure}

Although a detailed description of the Opal toolkit is beyond the scope of
this paper (and can be found in \cite{opal}), the overall architecture of
is shown in Figure \ref{fig:arch}. The salient features of Opal are as
follows:

\begin{itemize}
\item{Scheduling and Cluster Management}
\item{Data management and Persistence}
\item{Security}
\item{Standardized WSDL API}
\item{Argument Description and Dynamic Interface Generation}
\end{itemize}

- Opal wrapper and GUI: Sriram 

- Opal and Opal-CSF4: Sriram

- Data services: Sriram

- Status, more information

\begin{figure}
\begin{center}
\includegraphics[width=8cm]{opal-gui}
\end{center}
\caption{Service Invocation via the Opal GUI}
\label{fig:opal-gui}
\end{figure}

- Towards Opal2

\begin{figure}
\begin{center}
\includegraphics[width=8.5cm]{opal2-providers}
\end{center}
\caption{The Opal2 Provider Model}
\label{fig:opal2-providers}
\end{figure}

\section {Service based workflows}

- Vision based grid workflows (Michel, Guillaume, Sargis)

- Virtualization of Opal services (Sargis - something about how you
automatically create Vision nodes from the service list)

- Virtualization of Vision based workflows

  i) Use a local CLI opal client to access local or remote services (Sriram)

 ii) Automatic vision node creation through the opal client information
 service (Sriram, Guillaume - how the generated class is converted into a Vision node using introspection)

- PDB2PQR-APBS workflow in action

\section {Discussion - Workflow modeling and execution}

- How vision currently stores workflow (Michel)

- Fault tolerance (Michel, Sriram)

- Support for XPDL and other representations for workflows (Luca)

\section {Conclusions}

Visual programming environments enable non-programmers to intuitively and
interactively build scientific workflows and visualize their data, without
having to write code or understand the details of the back-end
infrastructure. In this paper, we described our tool called Vision, which
is a component-based, application-domain agnostic, cross-platform visual
programming environment. On the other hand, Grid computing provides an
enormous opportunity to scientific end-users to use distributed computing
and storage resources to enable novel science hitherto impossible using
traditional computing mechanisms. However, most Grid middleware tools are
complicated to install and too jargon rich for scientists to learn. In
order to simplify the use of Grid infrastructures, one has to provide easy
to use abstractions to the complex back-end functionality. Towards this
end, we have developed the Opal toolkit, which enables wrapping scientific
applications running on Grid resources as simple Web services, which can be
accessed via a number of user interfaces. In this paper, we described how
we can use the metadata provided by the Opal services to automatically
generate Vision nodes to access the applications running on Grid resources.
With the help of a molecular visualization workflow, we demonstrated how
this is being used by domain scientists, while being completely shielded
from the complexity of the back-end computational infrastructure. We
believe that the use of services-oriented science within visual programming
environments will go a long way towards lowering the entrance barrier for
scientific end-users to effectively use Grid middleware.

The authors would like to acknowledge support from the NIH P41 RR 08605 to
NBCR; TATRC W81XWH-07-2-0014 to PWA, the Gordon and Betty Moore Foundation
grant for the CAMERA project, and the NSF grants INT-0314015 and
OCI-0627026 for the PRAGMA project. 

%% References
\bibliographystyle{plain}
\bibliography{paper}

% that's all folks
\end{document}
